<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Properties
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="FsCheck is a tool for testing .NET programs automatically using randomly generated test cases."/>
    <meta name="author" content="Kurt Schelfthout and contributors"/>

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"/>

    <link type="text/css" rel="stylesheet" href="/FsCheck/content/style.css" />
    <script type="text/javascript" src="/FsCheck/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://github.com/fscheck/FsCheck/fork">Fork me on GitHub</a></li>
        </ul>
        <h3 class="muted"><a href="/FsCheck/index.html">FsCheck</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          
<h1><a name="Properties" class="anchor" href="#Properties">Properties</a></h1>
<p>Properties are expressed as F# function definitions or C# lambdas or methods.
Properties are universally quantified over their parameters, so</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">revRevIsOrig</span> (<span class="i">xs</span><span class="o">:</span><span class="i">list</span><span class="o">&lt;</span><span class="i">int</span><span class="o">&gt;</span>) <span class="o">=</span> <span class="i">List</span><span class="o">.</span><span class="i">rev</span>(<span class="i">List</span><span class="o">.</span><span class="i">rev</span> <span class="i">xs</span>) <span class="o">=</span> <span class="i">xs</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="k">public</span> <span class="k">static</span> <span class="k">bool</span> RevRevIsOriginal(<span class="k">int</span>[] ts) {
    <span class="k">return</span> ts.Reverse().Reverse().SequenceEqual(ts);
}</code></pre></td></tr></table>
<p>means that the equality holds for all lists xs.</p>
<p>Properties must not have generic types - because there can be so many different
kinds of constraints on generic types, some of which may not even be visible from the
type signature, we currently think allowing FsCheck to generate a generic type is not worth the added complexity.
It's very simple to fix any types anyway simply by adding some type annotations.</p>
<p>FsCheck can check properties of various forms - these forms are called testable,
and are indicated in the API by a generic type called <code>'Testable</code>. A <code>'Testable</code> may
be a function of any number of parameters that returns bool or unit. In the latter case,
a test passes if it does not throw. The entry point to create properties is the Prop module.</p>
<p>Like all of FsCheck's API, there are C# counterparts for all of the F# methods described.</p>
<h2><a name="Conditional-Properties" class="anchor" href="#Conditional-Properties">Conditional Properties</a></h2>
<p>Properties may take the form <code>&lt;condition&gt; ==&gt; &lt;property&gt;</code></p>
<p>For example,</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">insertKeepsOrder</span> (<span class="i">x</span><span class="o">:</span><span class="i">int</span>) <span class="i">xs</span> <span class="o">=</span> <span class="i">ordered</span> <span class="i">xs</span> <span class="o">==&gt;</span> <span class="i">ordered</span> (<span class="i">insert</span> <span class="i">x</span> <span class="i">xs</span>)
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">insertKeepsOrder</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">Prop.ForAll&lt;<span class="k">int</span>, <span class="k">int</span>[]<span class="o">&gt;</span>((x, xs) <span class="o">=</span><span class="o">&gt;</span> xs.Insert(x).IsOrdered().When(xs.IsOrdered()))
    .QuickCheck();</code></pre></td></tr></table>
<table class="pre"><tr><td><pre><code>Arguments exhausted after 25 tests.</code></pre></td></tr></table>
<p>Such a property holds if the property after <code>==&gt;</code> holds whenever the condition does.</p>
<p>Testing discards test cases which do not satisfy the condition. Test case generation
continues until 100 cases which do satisfy the condition have been found, or until
an overall limit on the number of test cases is reached (to avoid looping if the condition
never holds). In this case a message such as "Arguments exhausted after 97 tests."
indicates that 97 test cases satisfying the condition were found, and that the property held in those 97 cases.</p>
<p>Notice that in this case the generated values had to be restricted to int. This is because the generated
values need to be comparable, but this is not reflected in the types. Therefore, without the explicit
restriction, FsCheck could generate lists containing different types (subtypes of objects), and these are not mutually comparable.</p>
<h2><a name="Lazy-Properties" class="anchor" href="#Lazy-Properties">Lazy Properties</a></h2>
<p>Since F# has eager evaluation by default, the above property does more work than necessary:
it evaluates the property at the right of the condition no matter what the
outcome of the condition on the left. While only a performance consideration in the above
example, this may limit the expressiveness of properties - consider:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">tooEager</span> <span class="i">a</span> <span class="o">=</span> <span class="i">a</span> <span class="o">&lt;&gt;</span> <span class="n">0</span> <span class="o">==&gt;</span> (<span class="n">1</span><span class="o">/</span><span class="i">a</span> <span class="o">=</span> <span class="n">1</span><span class="o">/</span><span class="i">a</span>)
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">tooEager</span>
</code></pre>
<table class="pre"><tr><td><pre><code>Falsifiable, after 2 tests (0 shrinks) (StdGen (455847149,296344372)):
Original:
0
with exception:
System.DivideByZeroException: Attempted to divide by zero.
   at FSI_0025.tooEager(Int32 a) in C:\Users\Kurt\Projects\FsCheck\FsCheck\docs\tools\input.fsx:line 1
   at FsCheck.Testable.evaluate[a,b](FSharpFunc`2 body, a a)</code></pre></td></tr></table>
<p>Non-strict evaluation is needed here to make sure the propery is checked correctly:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">moreLazy</span> <span class="i">a</span> <span class="o">=</span> <span class="i">a</span> <span class="o">&lt;&gt;</span> <span class="n">0</span> <span class="o">==&gt;</span> (<span class="k">lazy</span> (<span class="n">1</span><span class="o">/</span><span class="i">a</span> <span class="o">=</span> <span class="n">1</span><span class="o">/</span><span class="i">a</span>))
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">moreLazy</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">Prop.ForAll&lt;<span class="k">int</span>&gt;(a <span class="o">=</span><span class="o">&gt;</span> <span class="k">new</span> Func&lt;<span class="k">bool</span>&gt;(() <span class="o">=</span><span class="o">&gt;</span> <span class="n">1</span> <span class="o">/</span> a <span class="o">=</span><span class="o">=</span> <span class="n">1</span> <span class="o">/</span> a).When(a <span class="o">!</span><span class="o">=</span> <span class="n">0</span>))
    .QuickCheck();</code></pre></td></tr></table>
<table class="pre"><tr><td><pre><code>Ok, passed 100 tests.</code></pre></td></tr></table>
<h2><a name="Quantified-Properties" class="anchor" href="#Quantified-Properties">Quantified Properties</a></h2>
<p>Properties may take the form <code>forAll &lt;arbitrary&gt;  (fun &lt;args&gt; -&gt; &lt;property&gt;)</code>.</p>
<p>For example,</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">orderedList</span> <span class="o">=</span> <span class="i">Arb</span><span class="o">.</span><span class="i">from</span><span class="o">&lt;</span><span class="i">list</span><span class="o">&lt;</span><span class="i">int</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="o">|&gt;</span> <span class="i">Arb</span><span class="o">.</span><span class="i">mapFilter</span> <span class="i">List</span><span class="o">.</span><span class="i">sort</span> <span class="i">ordered</span>
<span class="k">let</span> <span class="i">insertWithArb</span> <span class="i">x</span> <span class="o">=</span> <span class="i">Prop</span><span class="o">.</span><span class="i">forAll</span> <span class="i">orderedList</span> (<span class="k">fun</span> <span class="i">xs</span> <span class="k">-&gt;</span> <span class="i">ordered</span>(<span class="i">insert</span> <span class="i">x</span> <span class="i">xs</span>))
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">insertWithArb</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="k">var</span> orderedList <span class="o">=</span> Arb.From&lt;<span class="k">int</span>[]<span class="o">&gt;</span>()
                     .MapFilter(xs <span class="o">=</span><span class="o">&gt;</span> xs.OrderBy(i <span class="o">=</span><span class="o">&gt;</span> i).ToArray(), xs <span class="o">=</span><span class="o">&gt;</span> xs.IsOrdered());

Prop.ForAll&lt;<span class="k">int</span>&gt;(x <span class="o">=</span><span class="o">&gt;</span> Prop.ForAll(orderedList, xs <span class="o">=</span><span class="o">&gt;</span> xs.Insert(x).IsOrdered()))
    .QuickCheck();</code></pre></td></tr></table>
<table class="pre"><tr><td><pre><code>Ok, passed 100 tests.</code></pre></td></tr></table>
<p>The first argument of forAll is an IArbitrary instance. Such an instance
encapsulates a test data generator and a shrinker (more on that in <a href="TestData.html">Test Data</a>).
By supplying a custom generator, instead of using the default generator
for that type, it is possible to control the distribution of test data. In
the example, by supplying a custom generator for ordered lists, rather than
filtering out test cases which are not ordered, we guarantee that 100 test
cases can be generated without reaching the overall limit on test cases.
Combinators for defining generators are described in <a href="TestData.html">Test Data</a>.</p>
<h2><a name="Expecting-exceptions" class="anchor" href="#Expecting-exceptions">Expecting exceptions</a></h2>
<p>You may want to test that a function or method throws an exception under certain circumstances.
Use <code>throws&lt;'e :&gt; exn,'a&gt; Lazy&lt;'a&gt;</code> to achieve this. For example:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">expectDivideByZero</span>() <span class="o">=</span> <span class="i">Prop</span><span class="o">.</span><span class="i">throws</span><span class="o">&lt;</span><span class="i">DivideByZeroException</span>,_<span class="o">&gt;</span> (<span class="k">lazy</span> (<span class="i">raise</span> <span class="o">&lt;|</span> <span class="i">DivideByZeroException</span>()))
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">expectDivideByZero</span>
</code></pre>
<table class="pre"><tr><td><pre><code>Ok, passed 100 tests.</code></pre></td></tr></table>
<pre class="fssnip highlighted"><code lang="fsharp">  
</code></pre>
<p>This functionality is not available in the C# API.</p>
<h2><a name="Timed-Properties" class="anchor" href="#Timed-Properties">Timed Properties</a></h2>
<p>Properties may take the form <code>within &lt;timeout in ms&gt; &lt;Lazy&lt;property&gt;&gt;</code></p>
<p>For example,</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">timesOut</span> (<span class="i">a</span><span class="o">:</span><span class="i">int</span>) <span class="o">=</span> 
    <span class="k">lazy</span>
        <span class="k">if</span> <span class="i">a</span><span class="o">&gt;</span><span class="n">10</span> <span class="k">then</span>
            <span class="k">do</span> <span class="i">System</span><span class="o">.</span><span class="i">Threading</span><span class="o">.</span><span class="i">Thread</span><span class="o">.</span><span class="i">Sleep</span>(<span class="n">3000</span>)
            <span class="k">true</span>
        <span class="k">else</span> 
            <span class="k">true</span>
    <span class="o">|&gt;</span> <span class="i">Prop</span><span class="o">.</span><span class="i">within</span> <span class="n">1000</span>
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">timesOut</span>
</code></pre>
<p>The first argument is the time the lazy property may run. If it runs longer,
FsCheck considers the test as failed. Otherwise, the outcome of the lazy property is
the outcome of within. Note that, although within attempts to cancel the thread in which
the property is executed, that may not succeed, and so the thread may actually continue to run until the process ends.</p>
<p>This functionality is not available in the C# API.</p>
<h2><a name="Observing-Test-Case-Distribution" class="anchor" href="#Observing-Test-Case-Distribution">Observing Test Case Distribution</a></h2>
<p>It is important to be aware of the distribution of test cases: if test data is not well
distributed then conclusions drawn from the test results may be invalid. In particular,
the <code>==&gt;</code> operator can skew the distribution of test data badly, since only test data which
satisfies the given condition is used.</p>
<p>FsCheck provides several ways to observe the distribution of test data. Code for
making observations is incorporated into the statement of properties, each time
the property is actually tested the observation is made, and the collected observations
are then summarized when testing is complete.</p>
<h3><a name="Counting-Trivial-Cases" class="anchor" href="#Counting-Trivial-Cases">Counting Trivial Cases</a></h3>
<p>A property may take the form <code>trivial &lt;condition&gt; &lt;property&gt;</code></p>
<p>For example,</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">insertTrivial</span> (<span class="i">x</span><span class="o">:</span><span class="i">int</span>) <span class="i">xs</span> <span class="o">=</span> 
  <span class="i">ordered</span> <span class="i">xs</span> <span class="o">==&gt;</span> (<span class="i">ordered</span> (<span class="i">insert</span> <span class="i">x</span> <span class="i">xs</span>))
  <span class="o">|&gt;</span> <span class="i">Prop</span><span class="o">.</span><span class="i">trivial</span> (<span class="i">List</span><span class="o">.</span><span class="i">length</span> <span class="i">xs</span> <span class="o">=</span> <span class="n">0</span>)
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">insertTrivial</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">Prop.ForAll&lt;<span class="k">int</span>, <span class="k">int</span>[]<span class="o">&gt;</span>((x, xs) <span class="o">=</span><span class="o">&gt;</span>
            xs.Insert(x).IsOrdered()
            .When(xs.IsOrdered())
            .Classify(xs.Count() <span class="o">=</span><span class="o">=</span> <span class="n">0</span>, <span class="s">"trivial"</span>))
    .QuickCheck();</code></pre></td></tr></table>
<p>Test cases for which the condition is true are classified as trivial, and the proportion of
trivial test cases in the total is reported:</p>
<table class="pre"><tr><td><pre><code>Arguments exhausted after 12 tests (41% trivial).</code></pre></td></tr></table>
<h3><a name="Classifying-Test-Cases" class="anchor" href="#Classifying-Test-Cases">Classifying Test Cases</a></h3>
<p>A property may take the form <code>classify &lt;condition&gt; &lt;string&gt; &lt;property&gt;</code></p>
<p>For example,</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">insertClassify</span> (<span class="i">x</span><span class="o">:</span><span class="i">int</span>) <span class="i">xs</span> <span class="o">=</span> 
  <span class="i">ordered</span> <span class="i">xs</span> <span class="o">==&gt;</span> (<span class="i">ordered</span> (<span class="i">insert</span> <span class="i">x</span> <span class="i">xs</span>))
  <span class="o">|&gt;</span> <span class="i">Prop</span><span class="o">.</span><span class="i">classify</span> (<span class="i">ordered</span> (<span class="i">x</span><span class="o">::</span><span class="i">xs</span>)) <span class="s">&quot;at-head&quot;</span>
  <span class="o">|&gt;</span> <span class="i">Prop</span><span class="o">.</span><span class="i">classify</span> (<span class="i">ordered</span> (<span class="i">xs</span> <span class="o">@</span> [<span class="i">x</span>])) <span class="s">&quot;at-tail&quot;</span>
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">insertClassify</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">Prop.ForAll&lt;<span class="k">int</span>, <span class="k">int</span>[]<span class="o">&gt;</span>((x, xs) <span class="o">=</span><span class="o">&gt;</span>
        xs.Insert(x).IsOrdered()
        .When(xs.IsOrdered())
        .Classify(<span class="k">new</span>[] { x }.Concat(xs).IsOrdered(), <span class="s">"at-head"</span>)
        .Classify(xs.Concat(<span class="k">new</span> <span class="k">int</span>[] { x }).IsOrdered(), <span class="s">"at-tail"</span>))
    .QuickCheck();</code></pre></td></tr></table>
<p>Test cases satisfying the condition are assigned the classification given, and the distribution of
classifications is reported after testing:</p>
<table class="pre"><tr><td><pre><code>Arguments exhausted after 11 tests.
36% at-tail, at-head.
27% at-tail.
18% at-head.</code></pre></td></tr></table>
<p>Note that a test case may fall into more than one classification.</p>
<h3><a name="Collecting-Data-Values" class="anchor" href="#Collecting-Data-Values">Collecting Data Values</a></h3>
<p>A property may take the form <code>collect &lt;expression&gt; &lt;property&gt;</code></p>
<p>For example,</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">insertCollect</span> (<span class="i">x</span><span class="o">:</span><span class="i">int</span>) <span class="i">xs</span> <span class="o">=</span> 
  <span class="i">ordered</span> <span class="i">xs</span> <span class="o">==&gt;</span> (<span class="i">ordered</span> (<span class="i">insert</span> <span class="i">x</span> <span class="i">xs</span>))
      <span class="o">|&gt;</span> <span class="i">Prop</span><span class="o">.</span><span class="i">collect</span> (<span class="i">List</span><span class="o">.</span><span class="i">length</span> <span class="i">xs</span>)
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">insertCollect</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">Prop.ForAll&lt;<span class="k">int</span>, <span class="k">int</span>[]<span class="o">&gt;</span>((x, xs) <span class="o">=</span><span class="o">&gt;</span>
        xs.Insert(x).IsOrdered()
        .When(xs.IsOrdered())
        .Collect(<span class="s">"length "</span> <span class="o">+</span> xs.Count().ToString()))
    .QuickCheck();</code></pre></td></tr></table>
<p>The argument of collect is evaluated in each test case, and the distribution of
values is reported. The type of this argument is printed using <code>sprintf "%A"</code>:</p>
<table class="pre"><tr><td><pre><code>Arguments exhausted after 13 tests.
38% 1.
30% 0.
23% 2.
7% 3.</code></pre></td></tr></table>
<h3><a name="Combining-Observations" class="anchor" href="#Combining-Observations">Combining Observations</a></h3>
<p>The observations described here may be combined in any way. All the observations
of each test case are combined, and the distribution of these combinations is
reported. For example:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">insertCombined</span> (<span class="i">x</span><span class="o">:</span><span class="i">int</span>) <span class="i">xs</span> <span class="o">=</span> 
    <span class="i">ordered</span> <span class="i">xs</span> <span class="o">==&gt;</span> (<span class="i">ordered</span> (<span class="i">insert</span> <span class="i">x</span> <span class="i">xs</span>))
    <span class="o">|&gt;</span> <span class="i">Prop</span><span class="o">.</span><span class="i">classify</span> (<span class="i">ordered</span> (<span class="i">x</span><span class="o">::</span><span class="i">xs</span>)) <span class="s">&quot;at-head&quot;</span>
    <span class="o">|&gt;</span> <span class="i">Prop</span><span class="o">.</span><span class="i">classify</span> (<span class="i">ordered</span> (<span class="i">xs</span> <span class="o">@</span> [<span class="i">x</span>])) <span class="s">&quot;at-tail&quot;</span>
    <span class="o">|&gt;</span> <span class="i">Prop</span><span class="o">.</span><span class="i">collect</span> (<span class="i">List</span><span class="o">.</span><span class="i">length</span> <span class="i">xs</span>)
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">insertCombined</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">Prop.ForAll&lt;<span class="k">int</span>, <span class="k">int</span>[]<span class="o">&gt;</span>((x, xs) <span class="o">=</span><span class="o">&gt;</span>
        xs.Insert(x).IsOrdered()
        .When(xs.IsOrdered())
        .Classify(<span class="k">new</span> [] { x }.Concat(xs).IsOrdered(), <span class="s">"at-head"</span>)
        .Classify(xs.Concat(<span class="k">new</span> <span class="k">int</span>[] { x }).IsOrdered(), <span class="s">"at-tail"</span>)
        .Collect(<span class="s">"length "</span> <span class="o">+</span> xs.Count().ToString()))
    .QuickCheck();</code></pre></td></tr></table>
<table class="pre"><tr><td><pre><code>Arguments exhausted after 9 tests.
44% 1, at-head.
22% 0, at-tail, at-head.
11% 2, at-head.
11% 2.
11% 1, at-tail.</code></pre></td></tr></table>
<h2><a name="And-Or-and-Labels" class="anchor" href="#And-Or-and-Labels">And, Or and Labels</a></h2>
<p>Properties may take the form</p>
<ul>
<li><code>&lt;property&gt; .&amp;. &lt;property&gt;</code> succeeds if both succeed, fails if one of the properties fails, and is rejected when both are rejected.</li>
<li><code>&lt;property&gt; .|. &lt;property&gt;</code>succeeds if either property succeeds, fails if both properties fail, and is rejected when both are rejected.</li>
</ul>
<p>The <code>.&amp;.</code> combinator is most commonly used to write complex properties which share a generator.
In that case, it might be difficult upon failure to know excactly which sub-property has caused the failure.
That's why you can label sub-properties, and FsCheck shows the labels of the failed subproperties when
it finds a counter-example. This takes the form: <code>&lt;string&gt; @| &lt;property&gt;</code> or <code>&lt;property&gt; |@ &lt;string&gt;</code>.</p>
<p>For example,</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">complex</span> (<span class="i">m</span><span class="o">:</span> <span class="i">int</span>) (<span class="i">n</span><span class="o">:</span> <span class="i">int</span>) <span class="o">=</span>
  <span class="k">let</span> <span class="i">res</span> <span class="o">=</span> <span class="i">n</span> <span class="o">+</span> <span class="i">m</span>
  (<span class="i">res</span> <span class="o">&gt;</span><span class="o">=</span> <span class="i">m</span>)    <span class="o">|@</span> <span class="s">&quot;result &gt; #1&quot;</span> <span class="o">.</span><span class="o">&amp;.</span>
  (<span class="i">res</span> <span class="o">&gt;</span><span class="o">=</span> <span class="i">n</span>)    <span class="o">|@</span> <span class="s">&quot;result &gt; #2&quot;</span> <span class="o">.</span><span class="o">&amp;.</span> 
  (<span class="i">res</span> <span class="o">&lt;</span> <span class="i">m</span> <span class="o">+</span> <span class="i">n</span>) <span class="o">|@</span> <span class="s">&quot;result not sum&quot;</span>
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">complex</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">Prop.ForAll&lt;<span class="k">int</span>, <span class="k">int</span>&gt;((m, n) <span class="o">=</span><span class="o">&gt;</span> {
    <span class="k">var</span> result <span class="o">=</span> m <span class="o">+</span> n;
    <span class="k">return</span> (result <span class="o">&gt;</span><span class="o">=</span> m).Label(<span class="s">"result &gt; #1"</span>)
       .And(result <span class="o">&gt;</span><span class="o">=</span> n).Label(<span class="s">"result &gt; #2"</span>)
       .And(result <span class="o">&lt;</span> m <span class="o">+</span> n).Label(<span class="s">"result not sum"</span>);
}).QuickCheck();</code></pre></td></tr></table>
<table class="pre"><tr><td><pre><code>Falsifiable, after 1 test (2 shrinks) (StdGen (465702233,296344372)):
Label of failing property: result not sum
Original:
0
-2
Shrunk:
0
0</code></pre></td></tr></table>
<p>It's perfectly fine to apply more than one label to a property; FsCheck displays all the applicable labels.
This is useful for displaying intermediate results, for example:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">multiply</span> (<span class="i">n</span><span class="o">:</span> <span class="i">int</span>, <span class="i">m</span><span class="o">:</span> <span class="i">int</span>) <span class="o">=</span>
    <span class="k">let</span> <span class="i">res</span> <span class="o">=</span> <span class="i">n</span><span class="o">*</span><span class="i">m</span>
    <span class="i">sprintf</span> <span class="s">&quot;evidence = %i&quot;</span> <span class="i">res</span> <span class="o">@|</span> (
      <span class="s">&quot;div1&quot;</span> <span class="o">@|</span> (<span class="i">m</span> <span class="o">&lt;&gt;</span> <span class="n">0</span> <span class="o">==&gt;</span> <span class="k">lazy</span> (<span class="i">res</span> <span class="o">/</span> <span class="i">m</span> <span class="o">=</span> <span class="i">n</span>)) <span class="o">.</span><span class="o">&amp;.</span> 
      <span class="s">&quot;div2&quot;</span> <span class="o">@|</span> (<span class="i">n</span> <span class="o">&lt;&gt;</span> <span class="n">0</span> <span class="o">==&gt;</span> <span class="k">lazy</span> (<span class="i">res</span> <span class="o">/</span> <span class="i">n</span> <span class="o">=</span> <span class="i">m</span>)) <span class="o">.</span><span class="o">&amp;.</span> 
      <span class="s">&quot;lt1&quot;</span>  <span class="o">@|</span> (<span class="i">res</span> <span class="o">&gt;</span> <span class="i">m</span>) <span class="o">.</span><span class="o">&amp;.</span> 
      <span class="s">&quot;lt2&quot;</span>  <span class="o">@|</span> (<span class="i">res</span> <span class="o">&gt;</span> <span class="i">n</span>))
<span class="i">Check</span><span class="o">.</span><span class="i">Quick</span> <span class="i">multiply</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">Prop.ForAll&lt;<span class="k">int</span>, <span class="k">int</span>&gt;((n, m) <span class="o">=</span><span class="o">&gt;</span> {
    <span class="k">var</span> res <span class="o">=</span> n <span class="o">*</span> m;
    <span class="k">return</span> (<span class="k">new</span> Func&lt;<span class="k">bool</span>&gt;(() <span class="o">=</span><span class="o">&gt;</span> res <span class="o">/</span> m <span class="o">=</span><span class="o">=</span> n)).When(m <span class="o">!</span><span class="o">=</span> <span class="n">0.0</span>).Label(<span class="s">"div1"</span>)
      .And((<span class="k">new</span> Func&lt;<span class="k">bool</span>&gt;(() <span class="o">=</span><span class="o">&gt;</span> res <span class="o">/</span> n <span class="o">=</span><span class="o">=</span> m)).When(n <span class="o">!</span><span class="o">=</span> <span class="n">0.0</span>).Label(<span class="s">"div2"</span>))
      .And((res <span class="o">&gt;</span> m).Label(<span class="s">"lt1"</span>))
      .And((res <span class="o">&gt;</span> n).Label(<span class="s">"lt2"</span>))
      .Label(<span class="k">string</span>.Format(<span class="s">"evidence = {0}"</span>, res));
}).QuickCheck();</code></pre></td></tr></table>
<table class="pre"><tr><td><pre><code>Falsifiable, after 1 test (0 shrinks) (StdGen (466327680,296344372)):
Labels of failing property (one or more is failing):
evidence = 0
lt1
Original:
(0, 0)</code></pre></td></tr></table>
<p>Notice that the above property combines subproperties by tupling them. This works for tuples up to length 6 and lists:</p>
<ul>
<li><code>(&lt;property1&gt;,&lt;property2&gt;,...,&lt;property6&gt;)</code> means <code>&lt;property1&gt; .&amp;. &lt;property2&gt; .&amp;.... .&amp;.&lt;property6&gt;</code></li>
<li><code>[property1;property2,...,propertyN]</code> means <code>&lt;property1&gt; .&amp;. &lt;property2&gt; .&amp;.... .&amp;.&lt;propertyN&gt;</code></li>
</ul>
<p>The example written as a list:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">multiplyAsList</span> (<span class="i">n</span><span class="o">:</span> <span class="i">int</span>, <span class="i">m</span><span class="o">:</span> <span class="i">int</span>) <span class="o">=</span>
    <span class="k">let</span> <span class="i">res</span> <span class="o">=</span> <span class="i">n</span><span class="o">*</span><span class="i">m</span>
    <span class="i">sprintf</span> <span class="s">&quot;evidence = %i&quot;</span> <span class="i">res</span> <span class="o">@|</span> [
      <span class="s">&quot;div1&quot;</span> <span class="o">@|</span> (<span class="i">m</span> <span class="o">&lt;&gt;</span> <span class="n">0</span> <span class="o">==&gt;</span> <span class="k">lazy</span> (<span class="i">res</span> <span class="o">/</span> <span class="i">m</span> <span class="o">=</span> <span class="i">n</span>));
      <span class="s">&quot;div2&quot;</span> <span class="o">@|</span> (<span class="i">n</span> <span class="o">&lt;&gt;</span> <span class="n">0</span> <span class="o">==&gt;</span> <span class="k">lazy</span> (<span class="i">res</span> <span class="o">/</span> <span class="i">n</span> <span class="o">=</span> <span class="i">m</span>));
      <span class="s">&quot;lt1&quot;</span>  <span class="o">@|</span> (<span class="i">res</span> <span class="o">&gt;</span> <span class="i">m</span>);
      <span class="s">&quot;lt2&quot;</span>  <span class="o">@|</span> (<span class="i">res</span> <span class="o">&gt;</span> <span class="i">n</span>)]
</code></pre>
<p>Produces the same result.</p>


        </div>
        <div class="span3">
          <img src="/FsCheck/img/logo.png" alt="F# Project" style="width:150px;margin:10px" />  
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">FsCheck</li>
            <li><a href="/FsCheck/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="http://nuget.org/packages/FsCheck">Get Library via NuGet</a></li>
            <li><a href="http://github.com/fscheck/FsCheck">Source Code on GitHub</a></li>
            <li><a href="http://github.com/fscheck/FsCheck/blob/master/License.txt">License</a></li>
            <li><a href="http://github.com/fscheck/FsCheck/blob/master/FsCheck Release Notes.md">Release Notes</a></li>
            <li><a href="/FsCheck/users.html">Who is using FsCheck?</a></li>
            
            <li class="nav-header">Getting started</li>
            <li><a href="/FsCheck/QuickStart.html">Quick Start</a></li>
            <li><a href="/FsCheck/LearningResources.html">Learning Resources</a></li>

            <li class="nav-header">Documentation</li>
            <li>
              <a href="/FsCheck/Properties.html">Properties</a>
            </li>
            <li>
              <a href="/FsCheck/TestData.html">Generating test data</a>
            </li>
            <li>
              <a href="/FsCheck/StatefulTesting.html">Model-based testing</a>
            </li>
            <li>
              <a href="/FsCheck/RunningTests.html">Running tests</a>
            </li>
            <li>
              <a href="/FsCheck/TipsAndTricks.html">Tips and Tricks</a>
            </li>
              <li>
                  <a href="/FsCheck/StatefulTestingNew.html">Model-based testing vNext (Experimental)</a>
              </li>

            <li><a href="/FsCheck/reference/index.html">API Reference</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/fscheck/FsCheck">
      <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"/>
    </a>
  </body>
  </html>
